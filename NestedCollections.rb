# Nested Collections
# Этот урок продолжит развитие вашего знания о массивах и хэшах. Как вы уже заметили, массивы и хэши отлично подходят для хранения данных. Однако иногда данные 
# бывают более сложными и требуют более структурированного подхода, чем предлагают базовые массивы и хэши.
# Давайте рассмотрим, как можно использовать вложенные массивы и вложенные хэши для хранения более сложных данных

=begin
	

ChatGPT
Вложенные массивы
Массивы могут содержать любые типы данных, включая другие массивы. Массив, который содержит другие массивы, называется вложенным массивом или многомерным массивом.

Вложенные массивы могут быть полезны для хранения групп схожих данных или данных с позиционным отображением. Следующий вложенный массив с оценками тестов хранит 
группы схожих данных, а массив с почтовыми ящиками учителей хранит данные с позиционным отображением
	
=end

test_scores = [
  [97, 76, 79, 93],
  [79, 84, 76, 79],
  [88, 67, 64, 76],
  [94, 55, 67, 81]
]

teacher_mailboxes = [
  ["Adams", "Baker", "Clark", "Davis"],
  ["Jones", "Lewis", "Lopez", "Moore"],
  ["Perez", "Scott", "Smith", "Young"]
]

=begin
	
Доступ к элементам
Вы уже знаете, что каждый элемент в массиве имеет индекс. Для доступа к конкретному элементу во вложенном массиве используется вызов array[x][y], 
где x - индекс вложенного элемента, а y - индекс внутри этого вложенного элемента
	
=end

teacher_mailboxes[0][0]
#=> "Adams"
teacher_mailboxes[1][0]
#=> "Jones"
teacher_mailboxes[2][0]
#=> "Perez"

# Вы также можете использовать отрицательные индексы для получения элементов с конца массива, начиная с [-1]

teacher_mailboxes[0][-1]
#=> "Davis"
teacher_mailboxes[-1][0]
#=> "Perez"
teacher_mailboxes[-1][-2]
#=> "Smith"

=begin 

Если вы попытаетесь обратиться к индексу несуществующего вложенного элемента, возникнет ошибка NoMethodError, потому что класс nil не имеет метода []. 
Однако, так же как и в обычном массиве, если вы попытаетесь обратиться к несуществующему индексу внутри уже существующего вложенного элемента, он вернет значение nil

=end

# teacher_mailboxes[3][0]
#=> NoMethodError
teacher_mailboxes[0][4]
#=> nil

=begin 

Если вы хотите, чтобы при попытке доступа к индексу несуществующего вложенного элемента возвращалось значение nil, вы можете использовать метод #dig. 
Этот метод также может быть использован при доступе к несуществующему индексу внутри уже существующего вложенного элемента

=end

teacher_mailboxes.dig(3, 0)
#=> nil
teacher_mailboxes.dig(0, 4)
#=> nil

# Создание нового вложенного массива
=begin 

Теперь, когда вы увидели, как получить доступ к значениям внутри вложенного массива, мы должны немного отойти назад и рассмотреть создание нового вложенного массива. 
В предыдущем уроке вам было показано, как создать новый массив, вызывая метод `Array.new` с до двух необязательных аргументов (начальный размер и значение по умолчанию), 
например, `Array.new(3)` или `Array.new(3, 7)`. Однако здесь есть одна важная деталь, на которую следует обратить внимание. Согласно документации, второй необязательный 
аргумент, используемый для значения по умолчанию, должен быть только с неизменяемым объектом, таким как число, логическое значение или символ. Использование строки, 
массива, хэша или другого изменяемого объекта может привести к неожиданному поведению, потому что каждое значение по умолчанию в массиве будет ссылкой на один и тот же 
объект. Следовательно, любое изменение одного из элементов приведет к изменениям во всех элементах массива.

Чтобы создать массив неизменяемых объектов (строка, массив, хэш и т. д.), вам следует передать значение по умолчанию для `Array.new` через блок, используя фигурные скобки, 
вместо второго необязательного аргумента. Код в блоке будет выполняться для каждого слота в массиве, создавая множество объектов для инициализации массива, вместо ссылок 
на один объект.

Изменение значения первого элемента в первом вложенном массиве приводит к изменению первого элемента во всех трех вложенных массивах! Это же самое поведение произойдет 
при работе со строками, хэшами или любыми другими изменяемыми объектами.

=end

# Чтобы увидеть это на практике, рассмотрим два примера. В первом примере используется второй необязательный аргумент для значения по умолчанию

# Ruby интерпретирует это следующим образом:
# Array.new(2) создает новый массив из двух элементов, которые по умолчанию инициализированы значением nil. Таким образом, Array.new(2) возвращает [nil, nil].
# Затем Array.new(3, Array.new(2)) создает новый массив из трех элементов, каждый из которых является ссылкой на один и тот же массив [nil, nil]. То есть, внешний 
# массив имеет три элемента, и каждый элемент ссылается на один и тот же внутренний массив [nil, nil].

mutable = Array.new(3, Array.new(2))
#=> [[nil, nil], [nil, nil], [nil, nil]]

mutable[0][0] = 1000
#=> 1000
mutable
#=> [[1000, nil], [1000, nil], [1000, nil]]

# Теперь давайте рассмотрим пример, который не включает второй необязательный аргумент, а вместо этого передает изменяемое значение в блоке
# Изменение значения первого элемента в первом вложенном массиве не приводит к изменению значения в любом другом вложенном массиве.

immutable = Array.new(3) { Array.new(2) }
#=> [[nil, nil], [nil, nil], [nil, nil]]
immutable[0][0] = 1000
#=> 1000
immutable
#=> [[1000, nil], [nil, nil], [nil, nil]]

=begin 

Добавление и удаление элементов

Вы можете добавить еще один элемент в конец вложенного массива, используя метод #push или оператор <<. Если вы хотите добавить элемент 
в определённый вложенный массив, вам нужно указать индекс этого вложенного массива.

=end

test_scores = [
  [97, 76, 79, 93],
  [79, 84, 76, 79],
  [88, 67, 64, 76],
  [94, 55, 67, 81]
]

test_scores << [100, 99, 98, 97]
#=> [[97, 76, 79, 93], [79, 84, 76, 79], [88, 67, 64, 76], [94, 55, 67, 81], [100, 99, 98, 97]]
test_scores[0].push(100)
#=> [97, 76, 79, 93, 100]
test_scores
#=> [[97, 76, 79, 93, 100], [79, 84, 76, 79], [88, 67, 64, 76], [94, 55, 67, 81], [100, 99, 98, 97]]

#--------------------------------------------------------------------------------------------------------------------------------------------------------

test_scores = []

test_scores << 1
# => [1]

test_scores << [1, 2]
# => [1, [1, 2]]


#----------------------------------------------------------------------------------------------------------------------------------------------------------
# С использованием аналогичного синтаксиса вы можете добавлять или удалять элементы из всего вложенного массива или из конкретного вложенного элемента.

test_scores = [
  [97, 76, 79, 93],
  [79, 84, 76, 79],
  [88, 67, 64, 76],
  [94, 55, 67, 81],
  [100, 99, 98, 97]
]

# В Ruby метод pop используется для удаления последнего элемента из массива и возвращает удаленный элемент
test_scores.pop
#=> [100, 99, 98, 97]
test_scores[0].pop
#=> 100
test_scores
#=> [[97, 76, 79, 93], [79, 84, 76, 79], [88, 67, 64, 76], [94, 55, 67, 81]]

#---------------------------------------------------------------------------------------------------------------------------------------------------
=begin 
Итерация по вложенному массиву
Давайте разберем, как итерироваться по вложенному массиву с использованием метода #each_with_index. Можно представить вложенный массив как таблицу с рядами и столбцами. 
Каждый ряд представляет собой вложенный элемент, а каждый столбец — индекс вложенного элемента. Когда мы перебираем пример с почтовыми ящиками 
учителей (teacher_mailboxes), каждый элемент будет одним рядом.

=end

teacher_mailboxes = [
  ["Adams", "Baker", "Clark", "Davis"],
  ["Jones", "Lewis", "Lopez", "Moore"],
  ["Perez", "Scott", "Smith", "Young"]
]

teacher_mailboxes.each_with_index do |row, row_index|
  puts "Row:#{row_index} = #{row}"
end
#=> Row:0 = ["Adams", "Baker", "Clark", "Davis"]
#=> Row:1 = ["Jones", "Lewis", "Lopez", "Moore"]
#=> Row:2 = ["Perez", "Scott", "Smith", "Young"]

# Чтобы перебрать отдельные элементы внутри каждого ряда, вам нужно будет вложить другой перечислимый метод внутрь.

teacher_mailboxes.each_with_index do |row, row_index|
  row.each_with_index do |teacher, column_index|
    puts "Row:#{row_index} Column:#{column_index} = #{teacher}"
  end
end
#=> Row:0 Column:0 = Adams
#=> Row:0 Column:1 = Baker
#=> Row:0 Column:2 = Clark
#=> Row:0 Column:3 = Davis
#=> Row:1 Column:0 = Jones
#=> Row:1 Column:1 = Lewis
#=> Row:1 Column:2 = Lopez
#=> Row:1 Column:3 = Moore
#=> Row:2 Column:0 = Perez
#=> Row:2 Column:1 = Scott
#=> Row:2 Column:2 = Smith
#=> Row:2 Column:3 = Young

# Хотя эти примеры немного выдуманные, важно отметить, что если нам нужны только имена учителей, полезно использовать метод #flatten перед итерацией.

teacher_mailboxes.flatten.each do |teacher|
  puts "#{teacher} is amazing!"
end
#=> Adams is amazing!
#=> Baker is amazing!
#=> Clark is amazing!
#=> Davis is amazing!
#=> Jones is amazing!
#=> Lewis is amazing!
#=> Lopez is amazing!
#=> Moore is amazing!
#=> Perez is amazing!
#=> Scott is amazing!
#=> Smith is amazing!
#=> Young is amazing!

# Давайте рассмотрим более сложный пример вложенного использования двух предикативных перечислителей. Используя вышеуказанный вложенный массив оценок, 
# давайте определим, есть ли студенты, которые набрали более 80 баллов по всем предметам.

test_scores = [[97, 76, 79, 93], [79, 84, 76, 79], [88, 67, 64, 76], [94, 55, 67, 81]]
#=> [[97, 76, 79, 93], [79, 84, 76, 79], [88, 67, 64, 76], [94, 55, 67, 81]]

test_scores.any? do |scores|
  scores.all? { |score| score > 80 }
end
#=> false

=begin 
Это кажется довольно простым. Он возвращает false, потому что ни один из вложенных массивов не имеет оценок, которые все выше 80. Что вы думаете, 
что произойдет, если мы поменяем местами #any? и #all?? Думаете, мы получим те же результаты?
Результаты будут отличаться, потому что теперь проверяется, содержит ли каждый из вложенных массивов хотя бы одно число больше 80. Это вернет true, 
потому что каждый из вложенных массивов содержит хотя бы одно число больше 80.
=end

test_scores.all? do |scores|
  scores.any? { |score| score > 80 }
end
#=> true

#-----------------------------------------------------------------------------------------------------------------------------------------------

=begin
  
Вложенные хэши
Хэши, которые вы видели до сих пор, имели одну пару ключ/значение. Однако, как и массивы, они могут быть вложенными или многомерными. 
Вложенные хэши — это очень распространенный способ хранения сложных ассоциированных данных.
  
=end

vehicles = {
  alice: {year: 2019, make: "Toyota", model: "Corolla"},
  blake: {year: 2020, make: "Volkswagen", model: "Beetle"},
  caleb: {year: 2020, make: "Honda", model: "Accord"}
}

#Доступ к данным
puts vehicles[:alice][:year]
#=> 2019
puts vehicles[:blake][:make]
#=> "Volkswagen"
puts vehicles[:caleb][:model]
#=> "Accord"

=begin 

Аналогично вложенным массивам, если вы попытаетесь получить доступ к ключу в несуществующем вложенном хэше, будет вызвано 
исключение NoMethodError, поэтому вам может захотеться использовать метод #dig. Как ожидается, если вы попытаетесь получить доступ к несуществующему ключу в 
существующем вложенном хэше, вернётся значение nil

=end

#vehicles[:zoe][:year]
#=> NoMethodError
vehicles.dig(:zoe, :year)
#=> nil
vehicles[:alice][:color]
#=> nil
vehicles.dig(:alice, :color)
#=> nil

#Вы можете добавлять больше вложенных хэшей, как и в обычный хэш. Допустим, Дейв купил новый транспортное средство, и мы хотим добавить его в список

vehicles = {
  alice: {year: 2019, make: "Toyota", model: "Corolla"},
  blake: {year: 2020, make: "Volkswagen", model: "Beetle"},
  caleb: {year: 2020, make: "Honda", model: "Accord"}
}

vehicles[:dave] = {year: 2021, make: "Ford", model: "Escape"}
#=> {:year=>2021, :make=>"Ford", :model=>"Escape"}
puts vehicles
#=> {:alice=>{:year=>2019, :make=>"Toyota", :model=>"Corolla"}, :blake=>{:year=>2020, :make=>"Volkswagen", :model=>"Beetle"}, 
#:caleb=>{:year=>2020, :make=>"Honda", :model=>"Accord"}, :dave=>{:year=>2021, :make=>"Ford", :model=>"Escape"}}

=begin 

Также можно добавить элемент в один из вложенных хэшей. Допустим, Дейв очень любит свой новый "Escape" и считает, что нам следует 
отслеживать цвет транспортных средств. Чтобы добавить новую пару ключ/значение во вложенный хэш, укажите ключ вложенного хэша прямо перед названием нового ключа

=end

vehicles[:dave][:color] = "red"
#=> "red"
vehicles
#=> {:alice=>{:year=>2019, :make=>"Toyota", :model=>"Corolla"}, :blake=>{:year=>2020, :make=>"Volkswagen", :model=>"Beetle"}, :caleb=>{:year=>2020, :make=>"Honda", 
#:model=>"Accord"}, :dave=>{:year=>2021, :make=>"Ford", :model=>"Escape", :color=>"red"}}

#Удаление одного из вложенных хэшей будет аналогично удалению элемента из обычного хэша. Допустим, Блейк решил продать свою "Beetle" и отправиться в поход по Европе. 
#Так что давайте удалим машину Блейка из списка

vehicles.delete(:blake)
#=> {:year=>2020, :make=>"Volkswagen", :model=>"Beetle"}
vehicles
#=> {:alice=>{:year=>2019, :make=>"Toyota", :model=>"Corolla"}, :caleb=>{:year=>2020, :make=>"Honda", :model=>"Accord"}, :dave=>{:year=>2021, :make=>"Ford", 
#:model=>"Escape", :color=>"red"}}

#Чтобы удалить одну из пар ключ/значение во вложенном хэше, сначала указывается ключ внешнего хэша

vehicles[:dave].delete(:color)
#=> "red"
vehicles
#=> {:alice=>{:year=>2019, :make=>"Toyota", :model=>"Corolla"}, :caleb=>{:year=>2020, :make=>"Honda", :model=>"Accord"}, :dave=>{:year=>2021, :make=>"Ford", 
#:model=>"Escape"}}

=begin 

Методы
Существует множество полезных методов для работы с вложенными хэшами. Как только вы поймёте, какие данные вам нужны из вложенного хэша, вы можете обратиться 
к документации и экспериментировать с ними в IRB, чтобы лучше понять, как они работают.

Давайте рассмотрим пример с вложенным хэшем vehicles. Предположим, что нам нужно узнать, кто владеет транспортными средствами, выпущенными в 2020 году или позже. 
На первый взгляд в документации кажется, что метод #select будет отлично подходить для этой задачи

=end

vehicles = {
  alice: {year: 2019, make: "Toyota", model: "Corolla"},
  blake: {year: 2020, make: "Volkswagen", model: "Beetle"},
  caleb: {year: 2020, make: "Honda", model: "Accord"}
}

puts vehicles.select { |name, data| data[:year] >= 2020 }
#=> {:blake=>{:year=>2020, :make=>"Volkswagen", :model=>"Beetle"}, :caleb=>{:year=>2020, :make=>"Honda", :model=>"Accord"}}

=begin 

Да, использование метода #select позволяет получить необходимую информацию. Однако что, если нам нужны только имена владельцев, а не вся вложенная хэш-структура? 
Давайте продолжим изучать документацию, чтобы увидеть, что ещё мы можем найти. Метод #collect (или его псевдоним #map) кажется очень полезным для этой ситуации. 
Давайте соберём имена владельцев, если год выпуска равен 2020 или новее

=end

vehicles = {
  alice: {year: 2019, make: "Toyota", model: "Corolla"},
  blake: {year: 2020, make: "Volkswagen", model: "Beetle"},
  caleb: {year: 2020, make: "Honda", model: "Accord"}
}

puts vehicles.collect { |name, data| name if data[:year] >= 2020 }
#=> [nil, :caleb, :dave]

=begin 

Использование метода #collect приближает нас к тому, чтобы получить только имена владельцев новых автомобилей. Если посмотреть на этот метод в документации, 
вы увидите, что #collect и #map выполняют одну и ту же функцию. Оба этих метода используют возвращаемое значение каждой итерации, поэтому если условие if ложно, 
они вернут значение nil.

Значения nil могут вызывать проблемы в дальнейшем, поэтому давайте просмотрим документацию, чтобы найти метод, который поможет решить эту проблему. 
Метод #compact возвращает массив (или хэш) без значений nil, поэтому давайте добавим его в конец блока

=end

vehicles = {
  alice: {year: 2019, make: "Toyota", model: "Corolla"},
  blake: {year: 2020, make: "Volkswagen", model: "Beetle"},
  caleb: {year: 2020, make: "Honda", model: "Accord"}
}

puts vehicles.collect { |name, data| name if data[:year] >= 2020 }.compact
#=> [:caleb, :dave]

=begin 

Да, использование методов #collect и #compact позволяет получить нужные данные. Как видите, цепочка методов может быть очень полезной. Однако, если мы продолжим 
изучать документацию, мы обнаружим другой метод, который объединяет функциональность этих двух методов. В Ruby версии 2.7 добавлен новый метод перечисления под 
названием #filter_map, который звучит очень полезно для этой ситуации

=end

puts vehicles.filter_map { |name, data| name if data[:year] >= 2020 }
#=> [:caleb, :dave]
